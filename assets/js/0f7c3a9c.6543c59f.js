"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[64054],{41354:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>s,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>c});var t=n(85893),o=n(11151);const d={id:"binding-to-sorted-filtered-list",title:"Binding to Sorted/Filtered Data"},a=void 0,r={id:"guides/deep-dives/reactiveui/binding-to-sorted-filtered-list",title:"Binding to Sorted/Filtered Data",description:"A common UI task that applications need to do is display sorted and/or filtered 'views' of data. In Avalonia this can be accomplished by connecting a SourceCache or a SourceList to a ReadOnlyObservableCollection and binding to that collection",source:"@site/versioned_docs/version-0.10.x/guides/deep-dives/reactiveui/binding-to-sorted-filtered-list.md",sourceDirName:"guides/deep-dives/reactiveui",slug:"/guides/deep-dives/reactiveui/binding-to-sorted-filtered-list",permalink:"/avalonia-docs/docs/0.10.x/guides/deep-dives/reactiveui/binding-to-sorted-filtered-list",draft:!1,unlisted:!1,editUrl:"https://github.com/AvaloniaUI/avalonia-docs/tree/main/versioned_docs/version-0.10.x/guides/deep-dives/reactiveui/binding-to-sorted-filtered-list.md",tags:[],version:"0.10.x",frontMatter:{id:"binding-to-sorted-filtered-list",title:"Binding to Sorted/Filtered Data"},sidebar:"documentationSidebar",previous:{title:"Data Persistence",permalink:"/avalonia-docs/docs/0.10.x/guides/deep-dives/reactiveui/data-persistence"},next:{title:"Developer Guides",permalink:"/avalonia-docs/docs/0.10.x/guides/developer-guides/"}},s={},c=[{value:"Creating a Source Cache",id:"creating-a-source-cache",level:2},{value:"Creating Sorted Or Filtered Views",id:"creating-sorted-or-filtered-views",level:2},{value:"Binding",id:"binding",level:2}];function l(e){const i={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["A common UI task that applications need to do is display sorted and/or filtered 'views' of data. In Avalonia this can be accomplished by connecting a ",(0,t.jsx)(i.code,{children:"SourceCache<TObject, TKey>"})," or a ",(0,t.jsx)(i.code,{children:"SourceList<T>"})," to a ",(0,t.jsx)(i.code,{children:"ReadOnlyObservableCollection<T>"})," and binding to that collection"]}),"\n",(0,t.jsx)(i.h2,{id:"creating-a-source-cache",children:"Creating a Source Cache"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"SourceCache<TObject, TKey>"})," or ",(0,t.jsx)(i.code,{children:"SourceList<T>"})," come from ",(0,t.jsx)(i.a,{href:"https://www.reactiveui.net/docs/handbook/collections/",children:"Dynamic Data in ReactiveUI"}),"\nExample:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"// (x => x.Id) property that serves as the unique key for the cache\nprivate SourceCache<TestViewModel, Guid> _sourceCache = new (x => x.Id);\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Then the ",(0,t.jsx)(i.code,{children:"_sourceCache"})," can be populated through the ",(0,t.jsx)(i.code,{children:"AddOrUpdate"}),"  method"]}),"\n",(0,t.jsx)(i.h2,{id:"creating-sorted-or-filtered-views",children:"Creating Sorted Or Filtered Views"}),"\n",(0,t.jsxs)(i.p,{children:["Next the ",(0,t.jsx)(i.code,{children:"ReadOnlyObservableCollection<T>"})," can be bound to the filtered or sorted ",(0,t.jsx)(i.code,{children:"_sourceCache"}),".\nThe sorting/filtering is done similarly to linq."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csharp",children:"private readonly ReadOnlyObservableCollection<TestViewModel> _testViewModels;\npublic ReadOnlyObservableCollection<TestViewModel> TestViewModels => _testViewModels;\n...\npublic MainWindowViewModel(){\n    // Populate the source cache via _sourceCache.AddOrUpdate\n    ...\n    _sourceCache.Connect()\n        // Sort Ascending on the OrderIndex property\n        .Sort(SortExpressionComparer<TestViewModel>.Ascending(t => t.OrderIndex))\n        .Filter(x => x.Id.ToString().EndsWith('1'))\n        // Bind to our ReadOnlyObservableCollection<T>\n        .Bind(out _testViewModels)\n        // Subscribe for changes\n        .Subscribe();\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"binding",children:"Binding"}),"\n",(0,t.jsxs)(i.p,{children:["Now that the ",(0,t.jsx)(i.code,{children:"_sourceCache"})," is created and populated and the ",(0,t.jsx)(i.code,{children:"ReadOnlyObservableCollection<T>"})," is created and bound we can go into our view and bind exactly the way we normally would with an ",(0,t.jsx)(i.code,{children:"ObservableCollection<T>"})]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-markup",children:'    <Design.DataContext>\n        <vm:MainWindowViewModel/>\n    </Design.DataContext>\n\n    <TreeView Items="{Binding TestViewModels}">\n        <TreeView.DataTemplates>\n            !-- DataTemplate Definitions --\x3e\n        </TreeView.DataTemplates> \n    </TreeView>\n'})})]})}function h(e={}){const{wrapper:i}={...(0,o.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,i,n)=>{n.d(i,{Z:()=>r,a:()=>a});var t=n(67294);const o={},d=t.createContext(o);function a(e){const i=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(d.Provider,{value:i},e.children)}}}]);