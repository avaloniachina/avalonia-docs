"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[35277],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,g=u["".concat(s,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(g,r(r({ref:t},c),{},{components:n})):a.createElement(g,r({ref:t},c))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},55853:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const o={},r="Routing",l={unversionedId:"concepts/reactiveui/routing",id:"concepts/reactiveui/routing",title:"Routing",description:"ReactiveUI routing consists of an IScreen that contains current RoutingState, several IRoutableViewModels, and a platform-specific XAML control called RoutedViewHost. RoutingState manages the view model navigation stack and allows view models to navigate to other view models. IScreen is the root of a navigation stack; despite the name, its views don't have to occupy the whole screen. RoutedViewHost monitors an instance of RoutingState, responding to any changes in the navigation stack by creating and embedding the appropriate view.",source:"@site/docs/concepts/reactiveui/routing.md",sourceDirName:"concepts/reactiveui",slug:"/concepts/reactiveui/routing",permalink:"/avalonia-docs/docs/next/concepts/reactiveui/routing",draft:!1,editUrl:"https://github.com/AvaloniaUI/avalonia-docs/tree/main/docs/concepts/reactiveui/routing.md",tags:[],version:"current",frontMatter:{},sidebar:"documentationSidebar",previous:{title:"View Activation",permalink:"/avalonia-docs/docs/next/concepts/reactiveui/view-activation"},next:{title:"Data Persistence",permalink:"/avalonia-docs/docs/next/concepts/reactiveui/data-persistence"}},s={},p=[{value:"Routing Example",id:"routing-example",level:2}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"routing"},"Routing"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://reactiveui.net/docs/handbook/routing/"},"ReactiveUI routing")," consists of an ",(0,i.kt)("a",{parentName:"p",href:"https://reactiveui.net/api/reactiveui/iscreen/"},"IScreen")," that contains current ",(0,i.kt)("a",{parentName:"p",href:"https://reactiveui.net/api/reactiveui/routingstate/"},"RoutingState"),", several ",(0,i.kt)("a",{parentName:"p",href:"https://reactiveui.net/api/reactiveui/iroutableviewmodel/"},"IRoutableViewModel"),"s, and a platform-specific XAML control called ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/AvaloniaUI/Avalonia/blob/55458cf7af24d6c987268ab5ff8a1ead1173310b/src/Avalonia.ReactiveUI/RoutedViewHost.cs"},"RoutedViewHost"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutingState")," manages the view model navigation stack and allows view models to navigate to other view models. ",(0,i.kt)("inlineCode",{parentName:"p"},"IScreen")," is the root of a navigation stack; despite the name, its views don't have to occupy the whole screen. ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutedViewHost")," monitors an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutingState"),", responding to any changes in the navigation stack by creating and embedding the appropriate view."),(0,i.kt)("h2",{id:"routing-example"},"Routing Example"),(0,i.kt)("p",null,"Create a new empty project from Avalonia templates. To use those, clone the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/AvaloniaUI/avalonia-dotnet-templates"},"avalonia-dotnet-templates")," repository, install the templates and create a new project named ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutingExample")," based on ",(0,i.kt)("inlineCode",{parentName:"p"},"avalonia.app")," template. Install ",(0,i.kt)("inlineCode",{parentName:"p"},"Avalonia.ReactiveUI")," package into the project."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/AvaloniaUI/avalonia-dotnet-templates\ndotnet new --install ./avalonia-dotnet-templates\ndotnet new avalonia.app -o RoutingExample\ncd ./RoutingExample\ndotnet add package Avalonia.ReactiveUI\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"FirstViewModel.cs")),(0,i.kt)("p",null,"First, create routable view models and corresponding views. We derive routable view models from the ",(0,i.kt)("inlineCode",{parentName:"p"},"IRoutableViewModel")," interface from ",(0,i.kt)("inlineCode",{parentName:"p"},"ReactiveUI")," namespace, and from ",(0,i.kt)("inlineCode",{parentName:"p"},"ReactiveObject")," as well. ",(0,i.kt)("inlineCode",{parentName:"p"},"ReactiveObject")," is the base class for ",(0,i.kt)("a",{parentName:"p",href:"https://reactiveui.net/docs/handbook/view-models/"},"view model classes"),", and it implements ",(0,i.kt)("inlineCode",{parentName:"p"},"INotifyPropertyChanged"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"namespace RoutingExample\n{\n    public class FirstViewModel : ReactiveObject, IRoutableViewModel\n    {\n        // Reference to IScreen that owns the routable view model.\n        public IScreen HostScreen { get; }\n\n        // Unique identifier for the routable view model.\n        public string UrlPathSegment { get; } = Guid.NewGuid().ToString().Substring(0, 5);\n\n        public FirstViewModel(IScreen screen) => HostScreen = screen;\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"FirstView.xaml")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-markup"},'<UserControl xmlns="https://github.com/avaloniaui"\n             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"\n             x:Class="RoutingExample.FirstView">\n    <StackPanel HorizontalAlignment="Center"\n                VerticalAlignment="Center">\n        <TextBlock Text="Hi, I\'m the first view!" />\n        <TextBlock Text="{Binding UrlPathSegment}" />\n    </StackPanel>\n</UserControl>\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"FirstView.xaml.cs")),(0,i.kt)("p",null,"If we need to handle view model activation and deactivation, then we add a call to WhenActivated to the view. Generally, a rule of thumb is to always add WhenActivated to your views, see ",(0,i.kt)("a",{parentName:"p",href:"../../concepts/reactiveui/view-activation"},"Activation")," docs for more info."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"namespace RoutingExample\n{\n    public class FirstView : ReactiveUserControl<FirstViewModel>\n    {\n        public FirstView()\n        {\n            this.WhenActivated(disposables => { });\n            AvaloniaXamlLoader.Load(this);\n        }\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"MainWindowViewModel.cs")),(0,i.kt)("p",null,"Then, create a view model implementing the ",(0,i.kt)("inlineCode",{parentName:"p"},"IScreen")," interface. It contains current ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutingState")," that manages the navigation stack. ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutingState")," also contains helper commands allowing you to navigate back and forward."),(0,i.kt)("p",null,"Actually, you can use as many ",(0,i.kt)("inlineCode",{parentName:"p"},"IScreen"),"s as you need in your application. Despite the name, it doesn't have to occupy the whole screen. You can use nested routing, place ",(0,i.kt)("inlineCode",{parentName:"p"},"IScreen"),"s side-by-side, etc."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"namespace RoutingExample\n{\n    public class MainWindowViewModel : ReactiveObject, IScreen\n    {\n        // The Router associated with this Screen.\n        // Required by the IScreen interface.\n        public RoutingState Router { get; } = new RoutingState();\n\n        // The command that navigates a user to first view model.\n        public ReactiveCommand<Unit, IRoutableViewModel> GoNext { get; }\n\n        // The command that navigates a user back.\n        public ReactiveCommand<Unit, Unit> GoBack => Router.NavigateBack;\n\n        public MainWindowViewModel()\n        {\n            // Manage the routing state. Use the Router.Navigate.Execute\n            // command to navigate to different view models. \n            //\n            // Note, that the Navigate.Execute method accepts an instance \n            // of a view model, this allows you to pass parameters to \n            // your view models, or to reuse existing view models.\n            //\n            GoNext = ReactiveCommand.CreateFromObservable(\n                () => Router.Navigate.Execute(new FirstViewModel(this))\n            );\n        }\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"MainWindow.xaml")),(0,i.kt)("p",null,"Now we need to place the ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutedViewHost")," XAML control to our main view. It will resolve and embed appropriate views for the view models based on the supplied ",(0,i.kt)("inlineCode",{parentName:"p"},"IViewLocator")," implementation and the passed ",(0,i.kt)("inlineCode",{parentName:"p"},"Router")," instance of type ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutingState"),". Note, that you need to import ",(0,i.kt)("inlineCode",{parentName:"p"},"rxui")," namespace for ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutedViewHost")," to work. Additionally, you can override animations that are played when ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutedViewHost")," changes a view \u2014 simply override ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutedViewHost.PageTransition")," property in XAML. For latest builds from MyGet use ",(0,i.kt)("inlineCode",{parentName:"p"},'xmlns:rxui="https://reactiveui.net"'),", for 0.8.0 release on NuGet use ",(0,i.kt)("inlineCode",{parentName:"p"},'xmlns:rxui="clr-namespace:Avalonia;assembly=Avalonia.ReactiveUI"')," as in the example below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-markup"},'<Window xmlns="https://github.com/avaloniaui"\n        xmlns:rxui="clr-namespace:Avalonia.ReactiveUI;assembly=Avalonia.ReactiveUI"\n        xmlns:app="clr-namespace:RoutingExample"\n        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"\n        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"\n        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"\n        mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"\n        x:Class="RoutingExample.MainWindow"\n        Title="RoutingExample">\n    <Grid>\n        <Grid.RowDefinitions>\n            <RowDefinition Height="*" />\n            <RowDefinition Height="Auto" />\n        </Grid.RowDefinitions>\n        <rxui:RoutedViewHost Grid.Row="0" Router="{Binding Router}">\n            <rxui:RoutedViewHost.DefaultContent>\n                <TextBlock Text="Default content"\n                           HorizontalAlignment="Center"\n                           VerticalAlignment="Center" />\n            </rxui:RoutedViewHost.DefaultContent>\n            <rxui:RoutedViewHost.ViewLocator>\n                \x3c!-- See AppViewLocator.cs section below --\x3e\n                <app:AppViewLocator />\n            </rxui:RoutedViewHost.ViewLocator>\n        </rxui:RoutedViewHost>\n        <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="15">\n            <StackPanel.Styles>\n                <Style Selector="StackPanel > :is(Control)">\n                    <Setter Property="Margin" Value="2"/>\n                </Style>\n                <Style Selector="StackPanel > TextBlock">\n                    <Setter Property="VerticalAlignment" Value="Center"/>\n                </Style>\n            </StackPanel.Styles>\n            <Button Content="Go next" Command="{Binding GoNext}" />\n            <Button Content="Go back" Command="{Binding GoBack}" />\n            <TextBlock Text="{Binding Router.NavigationStack.Count}" />\n        </StackPanel>\n    </Grid>\n</Window>\n')),(0,i.kt)("p",null,"To disable the animations, simply set the ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutedViewHost.PageTransition")," property to ",(0,i.kt)("inlineCode",{parentName:"p"},"{x:Null}"),", like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-markup"},'<rxui:RoutedViewHost Grid.Row="0" Router="{Binding Router}" PageTransition="{x:Null}">\n    <rxui:RoutedViewHost.DefaultContent>\n        <TextBlock Text="Default content"\n                   HorizontalAlignment="Center"\n                   VerticalAlignment="Center" />\n    </rxui:RoutedViewHost.DefaultContent>\n</rxui:RoutedViewHost>\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"AppViewLocator.cs")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"AppViewLocator")," that we are passing to the ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutedViewHost")," control declared in the ",(0,i.kt)("inlineCode",{parentName:"p"},"MainWindow.xaml")," markup shown above is responsible for resolving a View based on the type of the ViewModel. The ",(0,i.kt)("inlineCode",{parentName:"p"},"IScreen.Router")," instance of type ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutingState")," determines which ViewModel should be currently shown. See ",(0,i.kt)("a",{parentName:"p",href:"https://reactiveui.net/docs/handbook/view-location/"},"View Location")," for details. The simplest possible ",(0,i.kt)("inlineCode",{parentName:"p"},"IViewLocator")," implementation based on pattern matching might look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"namespace RoutingExample\n{\n    public class AppViewLocator : ReactiveUI.IViewLocator\n    {\n        public IViewFor ResolveView<T>(T viewModel, string contract = null) => viewModel switch\n        {\n            FirstViewModel context => new FirstView { DataContext = context },\n            _ => throw new ArgumentOutOfRangeException(nameof(viewModel))\n        };\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"MainWindow.xaml.cs")),(0,i.kt)("p",null,"Here is the code-behind for ",(0,i.kt)("inlineCode",{parentName:"p"},"MainWindow.xaml")," declared above."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"namespace RoutingExample\n{\n    public class MainWindow : ReactiveWindow<MainWindowViewModel>\n    {\n        public MainWindow()\n        {\n            this.WhenActivated(disposables => { });\n            AvaloniaXamlLoader.Load(this);\n        }\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"App.axaml.cs")),(0,i.kt)("p",null,"Make sure you initialize the ",(0,i.kt)("inlineCode",{parentName:"p"},"DataContext")," of your root view in ",(0,i.kt)("inlineCode",{parentName:"p"},"App.axaml.cs")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public override void OnFrameworkInitializationCompleted()\n{\n    if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)\n    {\n        desktop.MainWindow = new MainWindow\n        {\n            DataContext = new MainWindowViewModel(),\n        };\n    }\n\n    base.OnFrameworkInitializationCompleted();\n}\n")),(0,i.kt)("p",null,"Finally, add ",(0,i.kt)("inlineCode",{parentName:"p"},".UseReactiveUI()")," to your ",(0,i.kt)("inlineCode",{parentName:"p"},"AppBuilder"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"namespace RoutingExample\n{\n    public static class Program\n    {\n        public static void Main(string[] args)\n        {\n            BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);\n        }\n\n        public static AppBuilder BuildAvaloniaApp() =>\n            AppBuilder.Configure<App>()\n                .UseReactiveUI()\n                .UsePlatformDetect()\n                .LogToDebug();\n    }\n}\n")),(0,i.kt)("p",null,"Now, you can run the app and see routing in action!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet run --framework netcoreapp2.1\n")),(0,i.kt)("img",{src:"/img/gitbook-import/assets/routing.gif",alt:""}))}d.isMDXComponent=!0}}]);