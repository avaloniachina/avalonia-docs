"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[58817],{36694:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var n=o(85893),r=o(11151);const s={id:"troubleshooting",title:"Troubleshooting"},l=void 0,i={id:"styling/troubleshooting",title:"Troubleshooting",description:"Avalonia styling system is a mix of XAML and CSS styling approaches, so developers with knowledge of only one of these technologies can be confused by details of another one.",source:"@site/versioned_docs/version-0.10.x/styling/troubleshooting.md",sourceDirName:"styling",slug:"/styling/troubleshooting",permalink:"/avalonia-docs/docs/0.10.x/styling/troubleshooting",draft:!1,unlisted:!1,editUrl:"https://github.com/AvaloniaUI/avalonia-docs/tree/main/versioned_docs/version-0.10.x/styling/troubleshooting.md",tags:[],version:"0.10.x",frontMatter:{id:"troubleshooting",title:"Troubleshooting"},sidebar:"documentationSidebar",previous:{title:"Resources",permalink:"/avalonia-docs/docs/0.10.x/styling/resources"},next:{title:"Controls",permalink:"/avalonia-docs/docs/0.10.x/controls/"}},a={},d=[{value:"Selector targets a control that doesn&#39;t exist",id:"selector-targets-a-control-that-doesnt-exist",level:3},{value:"Target property is overridden by another style",id:"target-property-is-overridden-by-another-style",level:3},{value:"Locally set Properties override Styles",id:"locally-set-properties-override-styles",level:3},{value:"Missing style pseudoclass (trigger) selector",id:"missing-style-pseudoclass-trigger-selector",level:3},{value:"Selector with a pseudoclass doesn&#39;t override the default",id:"selector-with-a-pseudoclass-doesnt-override-the-default",level:3},{value:"Previous value of specific properties is not restored when style is not applied anymore",id:"previous-value-of-specific-properties-is-not-restored-when-style-is-not-applied-anymore",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Avalonia styling system is a mix of XAML and CSS styling approaches, so developers with knowledge of only one of these technologies can be confused by details of another one."}),"\n",(0,n.jsx)(t.p,{children:"Let's imagine a problem when one or all style setters are not applied to the control. Below we will list common possible reasons and solutions."}),"\n",(0,n.jsx)(t.h3,{id:"selector-targets-a-control-that-doesnt-exist",children:"Selector targets a control that doesn't exist"}),"\n",(0,n.jsx)(t.p,{children:"Avalonia selectors, like CSS selectors, do not raise any errors or warnings, when there are no controls which can be matched by the selector. This includes using a name or class that doesn't exist or a child selector when there are no children to match the inner selector. The reason is simple, one style can target many controls, that can be created or removed at runtime, so there is no possible way to validate the selector."}),"\n",(0,n.jsx)(t.h3,{id:"target-property-is-overridden-by-another-style",children:"Target property is overridden by another style"}),"\n",(0,n.jsxs)(t.p,{children:["Styles are applied in order of declaration. If there are ",(0,n.jsx)(t.strong,{children:"multiple"})," style files that target the same control property, one style can override the other:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-markup",metastring:'title="Styles1.axaml"',children:'<Style Selector="TextBlock.header">\n    <Style Property="Foreground" Value="Blue" />\n    <Style Property="FontSize" Value="16" />\n</Style>\n'})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-markup",metastring:'title="Styles2.axaml"',children:'<Style Selector="TextBlock.header">\n    <Style Property="Foreground" Value="Green" />\n</Style>\n'})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-markup",metastring:'title="App.axaml"',children:'<StyleInclude Source="Style1.axaml" />\n<StyleInclude Source="Style2.axaml" />\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Here styles from file ",(0,n.jsx)(t.strong,{children:"Styles1.axaml"})," were applied first, so setters in styles of file ",(0,n.jsx)(t.strong,{children:"Styles2.axaml"}),' take priority. The resulting TextBlock will have FontSize="16" and Foreground="Green". The same order prioritization happens within style files also.']}),"\n",(0,n.jsx)(t.h3,{id:"locally-set-properties-override-styles",children:"Locally set Properties override Styles"}),"\n",(0,n.jsx)(t.p,{children:"Similarly, to WPF, Avalonia properties can have multiple values, often of different priorities."}),"\n",(0,n.jsx)(t.p,{children:"In this example you can see that local value (defined directly on the control) has higher priority than style value, so text block will have red foreground:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-markup",children:'<TextBlock Classes="header" Foreground="Red" />\n...\n<Style Selector="TextBlock.header">\n    <Setter Property="Foreground" Value="Green" />\n</Style>\n'})}),"\n",(0,n.jsxs)(t.p,{children:["You can see the full list of value priorities in the ",(0,n.jsx)(t.a,{href:"http://reference.avaloniaui.net/api/Avalonia.Data/BindingPriority/",children:"BindingPriority"})," enum, where lower enum values have higher priority. For example ",(0,n.jsx)(t.code,{children:"Animation"})," values have the highest priority and even override local values."]}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"Some default Avalonia styles use local values in their templates instead of template bindings or styles-setters, which makes it impossible to update template property without replacing whole template."})}),"\n",(0,n.jsx)(t.h3,{id:"missing-style-pseudoclass-trigger-selector",children:"Missing style pseudoclass (trigger) selector"}),"\n",(0,n.jsx)(t.p,{children:"Let's imagine a situation in which you might expect a second style to override previous one, but it doesn't:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-markup",children:'<Style Selector="Border:pointerover">\n    <Setter Property="Background" Value="Blue" />\n</Style>\n<Style Selector="Border">\n    <Setter Property="Background" Value="Red" />\n</Style>\n...\n<Border Width="100" Height="100" Margin="100" />\n'})}),"\n",(0,n.jsxs)(t.p,{children:["With this code example the ",(0,n.jsx)(t.code,{children:"Border"})," has a Red background normally and Blue when the pointer is over it. This is because as with CSS more specific selectors have precedence. It is an issue, when you want to override default styles of any state (pointerover, pressed or others) with a single style. To achieve it you will need to have new styles for these states as well."]}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsxs)(t.p,{children:["Visit the Avalonia source code to find the ",(0,n.jsx)(t.a,{href:"https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls",children:"original templates"})," when this happens and copy and paste the styles with pseudoclasses into your code."]})}),"\n",(0,n.jsx)(t.h3,{id:"selector-with-a-pseudoclass-doesnt-override-the-default",children:"Selector with a pseudoclass doesn't override the default"}),"\n",(0,n.jsx)(t.p,{children:"The following code example of styles that can be expected to work on top of default styles:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-markup",children:'<Style Selector="Button">\n    <Setter Property="Background" Value="Red" />\n</Style>\n<Style Selector="Button:pointerover">\n    <Setter Property="Background" Value="Blue" />\n</Style>\n'})}),"\n",(0,n.jsxs)(t.p,{children:["You might expect the ",(0,n.jsx)(t.code,{children:"Button"})," to be red by default and blue when pointer is over it. In fact, only setter of first style will be applied, and second one will be ignored."]}),"\n",(0,n.jsxs)(t.p,{children:["The reason is hidden in the Button's template. You can find the default templates in the Avalonia source code (old ",(0,n.jsx)(t.a,{href:"https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Themes.Default/Button.xaml",children:"Default"})," theme and new ",(0,n.jsx)(t.a,{href:"https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Themes.Fluent/Controls/Button.xaml",children:"Fluent"})," theme), but for convenience here we have simplified one from the Fluent theme:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-markup",children:'<Style Selector="Button">\n    <Setter Property="Background" Value="{DynamicResource ButtonBackground}"/>\n    <Setter Property="Template">\n        <ControlTemplate>\n            <ContentPresenter Name="PART_ContentPresenter"\n                              Background="{TemplateBinding Background}"\n                              Content="{TemplateBinding Content}"/>\n        </ControlTemplate>\n    </Setter>\n</Style>\n<Style Selector="Button:pointerover /template/ ContentPresenter#PART_ContentPresenter">\n    <Setter Property="Background" Value="{DynamicResource ButtonBackgroundPointerOver}" />\n</Style>\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The actual background is rendered by a ",(0,n.jsx)(t.code,{children:"ContentPresenter"}),", which in the default is bound to the Buttons ",(0,n.jsx)(t.code,{children:"Background"})," property. However in the pointer-over state the selector is directly applying the background to the ",(0,n.jsx)(t.code,{children:"ContentPresenter (Button:pointerover /template/ ContentPresenter#PART_ContentPresenter"}),") That's why when our setter was ignored in the previous code example. The corrected code should target content presenter directly as well:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-markup",children:'\x3c!-- Here #PART_ContentPresenter name selector is not necessary, but was added to have more specific style --\x3e\n<Style Selector="Button:pointerover /template/ ContentPresenter#PART_ContentPresenter">\n    <Setter Property="Background" Value="Blue" />\n</Style>\n'})}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"You can see this behavior for all controls in the default themes (both old Default and the new Fluent), not just Button. And not just for Background, but also other state-dependent properties."})}),"\n",(0,n.jsxs)(t.admonition,{type:"info",children:[(0,n.jsxs)(t.p,{children:["Why default styles change the ContentPresenter ",(0,n.jsx)(t.code,{children:"Background"})," property directly instead of changing the ",(0,n.jsx)(t.code,{children:"Button.Background"})," property?"]}),(0,n.jsxs)(t.p,{children:["This is because if the user were to set a local value on the button, it would override all styles, and make button always the same color. For more details see this ",(0,n.jsx)(t.a,{href:"https://github.com/AvaloniaUI/Avalonia/pull/2662#issuecomment-515764732",children:"reverted PR"}),"."]})]}),"\n",(0,n.jsx)(t.h3,{id:"previous-value-of-specific-properties-is-not-restored-when-style-is-not-applied-anymore",children:"Previous value of specific properties is not restored when style is not applied anymore"}),"\n",(0,n.jsxs)(t.p,{children:["In Avalonia we have multiple types of properties, and one of them, Direct Property, doesn't support styling at all. These properties work in simplified way to achieve lower overhead and higher performance, and do not store multiple values depending on priority. Instead only latest value is saved and cannot be restored. You can find more details about properties ",(0,n.jsx)(t.a,{href:"/avalonia-docs/docs/0.10.x/authoring-controls/defining-properties#direct-avaloniaproperties",children:"here"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Typical example is ",(0,n.jsx)(t.a,{href:"http://reference.avaloniaui.net/api/Avalonia.Controls/Button/B9689B29",children:"CommandProperty"}),". It is defined as a DirectProperty, and it will never work properly.\nIn the future attempt to style direct property will be resulted in compile time error, see ",(0,n.jsx)(t.a,{href:"https://github.com/AvaloniaUI/Avalonia/issues/6837",children:"#6837"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},11151:(e,t,o)=>{o.d(t,{Z:()=>i,a:()=>l});var n=o(67294);const r={},s=n.createContext(r);function l(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);