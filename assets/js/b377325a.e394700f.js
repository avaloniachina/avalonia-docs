"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[5197],{63917:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var i=t(85893),o=t(11151);const a={id:"locating-views",title:"Locating Views"},s=void 0,l={id:"tutorials/todo-list-app/locating-views",title:"Locating Views",description:"Hold on, rewind a second. An observant reader will have noticed something strange going on in the last section.",source:"@site/versioned_docs/version-0.10.x/tutorials/todo-list-app/locating-views.md",sourceDirName:"tutorials/todo-list-app",slug:"/tutorials/todo-list-app/locating-views",permalink:"/avalonia-docs/docs/0.10.x/tutorials/todo-list-app/locating-views",draft:!1,unlisted:!1,editUrl:"https://github.com/AvaloniaUI/avalonia-docs/tree/main/versioned_docs/version-0.10.x/tutorials/todo-list-app/locating-views.md",tags:[],version:"0.10.x",frontMatter:{id:"locating-views",title:"Locating Views"},sidebar:"documentationSidebar",previous:{title:"Wiring up the Views",permalink:"/avalonia-docs/docs/0.10.x/tutorials/todo-list-app/wiring-up-the-views"},next:{title:"Adding new Items",permalink:"/avalonia-docs/docs/0.10.x/tutorials/todo-list-app/adding-new-items"}},c={},d=[];function r(e){const n={a:"a",admonition:"admonition",code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Hold on, rewind a second. An observant reader will have noticed something strange going on ",(0,i.jsx)(n.a,{href:"wiring-up-the-views",children:"in the last section"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Views/MainWindow.axaml"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-markup",children:'<Window xmlns="https://github.com/avaloniaui"\n        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"\n        x:Class="Todo.Views.MainWindow"\n        Icon="/Assets/avalonia-logo.ico"\n        Width="200" Height="300"\n        Title="Avalonia Todo"\n        Content="{Binding List}">\n</Window>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We bound the ",(0,i.jsx)(n.code,{children:"Window.Content"})," property to the ",(0,i.jsx)(n.code,{children:"MainWindowViewModel.List"})," property which is an instance of ",(0,i.jsx)(n.code,{children:"TodoListViewModel"})," but the window is displaying a ",(0,i.jsx)(n.code,{children:"TodoListView"}),"! What's happening here? How is a view being displayed when the window content is a view model?"]}),"\n",(0,i.jsxs)(n.p,{children:["The answer can be found in ",(0,i.jsx)(n.code,{children:"ViewLocator.cs"})," which was a file added by the template:"]}),"\n",(0,i.jsx)(n.p,{children:"ViewLocator.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing Avalonia.Controls;\nusing Avalonia.Controls.Templates;\nusing Todo.ViewModels;\n\nnamespace Todo\n{\n    public class ViewLocator : IDataTemplate\n    {\n        public bool SupportsRecycling => false;\n\n        public IControl Build(object data)\n        {\n            var name = data.GetType().FullName.Replace("ViewModel", "View");\n            var type = Type.GetType(name);\n\n            if (type != null)\n            {\n                return (Control)Activator.CreateInstance(type);\n            }\n            else\n            {\n                return new TextBlock { Text = "Not Found: " + name };\n            }\n        }\n\n        public bool Match(object data)\n        {\n            return data is ViewModelBase;\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ViewLocator"})," defines a ",(0,i.jsx)(n.a,{href:"../../templates/data-templates",children:"data template"})," which converts view models into views. It defines two methods:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Match(object data)"})," looks at the data and if the data inherits from ",(0,i.jsx)(n.code,{children:"ViewModelBase"})," it returns ",(0,i.jsx)(n.code,{children:"true"})," indicating that ",(0,i.jsx)(n.code,{children:"Build"})," should be called"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Build(object data)"})," takes the fully qualified name of the data's type and replaces the string ",(0,i.jsx)(n.code,{children:'"ViewModel"'})," with the string ",(0,i.jsx)(n.code,{children:'"View"'}),". It then tries to get a type that matches that name. If a matching type is found, it creates an instance of the type and returns it"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["An instance of ",(0,i.jsx)(n.code,{children:"ViewLocator"})," is present in ",(0,i.jsx)(n.code,{children:"Application.DataTemplates"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-markup",children:'<Application xmlns="https://github.com/avaloniaui"\n             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"\n             xmlns:local="clr-namespace:Todo"\n             x:Class="Todo.App">\n    <Application.DataTemplates>\n        <local:ViewLocator/>\n    </Application.DataTemplates>\n\n    <Application.Styles>\n        <StyleInclude Source="avares://Avalonia.Themes.Default/DefaultTheme.xaml"/>\n        <StyleInclude Source="avares://Avalonia.Themes.Default/Accents/BaseLight.xaml"/>\n    </Application.Styles>\n</Application>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When an instance of ",(0,i.jsx)(n.a,{href:"../../controls/contentcontrol",children:"ContentControl"})," (such as ",(0,i.jsx)(n.code,{children:"Window"}),") has its ",(0,i.jsx)(n.code,{children:"Content"})," property set to a non-control, it searches up the tree of controls for a ",(0,i.jsx)(n.code,{children:"DataTemplate"})," that matches the content data. If no other ",(0,i.jsx)(n.code,{children:"DataTemplate"})," matches the data it will eventually reach the ",(0,i.jsx)(n.code,{children:"ViewLocator"})," in the application data templates which will do its business and return an instance of the corresponding view."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ViewLocator"})," is included in the project's source instead of being a component of Avalonia itself because the mechanism of relating a view model to a view may be application-specific; for example one might want to implement it using a DI framework. ",(0,i.jsx)(n.code,{children:"ViewLocator"})," can be thought of as implementing the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Convention_over_configuration",children:"convention over configuration"})," paradigm."]})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>s});var i=t(67294);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);