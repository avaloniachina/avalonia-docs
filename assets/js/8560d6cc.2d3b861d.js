"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[39813],{3720:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>l});var o=n(85893),i=n(11151);const s={description:"TUTORIALS - To Do List App"},a="Process a New Item",d={id:"tutorials/todo-list-app/process-a-new-item",title:"Process a New Item",description:"TUTORIALS - To Do List App",source:"@site/docs/tutorials/todo-list-app/process-a-new-item.md",sourceDirName:"tutorials/todo-list-app",slug:"/tutorials/todo-list-app/process-a-new-item",permalink:"/avalonia-docs/docs/tutorials/todo-list-app/process-a-new-item",draft:!1,unlisted:!1,editUrl:"https://github.com/AvaloniaUI/avalonia-docs/tree/main/docs/tutorials/todo-list-app/process-a-new-item.md",tags:[],version:"current",frontMatter:{description:"TUTORIALS - To Do List App"},sidebar:"documentationSidebar",previous:{title:"Add Item Buttons",permalink:"/avalonia-docs/docs/tutorials/todo-list-app/add-item-buttons"},next:{title:"Conclusion",permalink:"/avalonia-docs/docs/tutorials/todo-list-app/conclusion"}},c={},l=[];function r(e){const t={a:"a",code:"code",h1:"h1",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"process-a-new-item",children:"Process a New Item"}),"\n",(0,o.jsxs)(t.p,{children:["On this page you will learn how to process the output from the OK and cancel buttons being pressed and re-show the list. If OK was pressed we also need to add the new item to the list. We'll implement this functionality in ",(0,o.jsx)(t.code,{children:"MainWindowViewModel"}),":"]}),"\n",(0,o.jsx)(t.p,{children:"To alter the main window view model, follow this procedure:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Stop the app if it is running."}),"\n",(0,o.jsxs)(t.li,{children:["Locate the ",(0,o.jsx)(t.strong,{children:"MainWindowViewModel.cs"})," file in the ",(0,o.jsx)(t.strong,{children:"/ViewModels"})," folder."]}),"\n",(0,o.jsx)(t.li,{children:"Edit the code as shown."}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"using ReactiveUI;\nusing System;\nusing System.Reactive.Linq;\nusing ToDoList.DataModel;\nusing ToDoList.Services;\n\nnamespace ToDoList.ViewModels\n{\n    public class MainWindowViewModel : ViewModelBase\n    {\n        private ViewModelBase _contentViewModel;\n\n        //this has a dependency on the ToDoListService\n\n        public MainWindowViewModel()\n        {\n            var service = new ToDoListService();\n            ToDoList = new ToDoListViewModel(service.GetItems());\n            _contentViewModel = ToDoList;\n        }\n\n        public ViewModelBase ContentViewModel\n        {\n            get => _contentViewModel;\n            private set => this.RaiseAndSetIfChanged(ref _contentViewModel, value);\n        }\n\n        public ToDoListViewModel ToDoList { get; }\n\n        public void AddItem()\n        {\n            AddItemViewModel addItemViewModel = new();\n\n            Observable.Merge(\n                addItemViewModel.OkCommand,\n                addItemViewModel.CancelCommand.Select(_ => (ToDoItem?)null))\n                .Take(1)\n                .Subscribe(newItem =>\n                {\n                    if (newItem != null)\n                    {\n                        ToDoList.ListItems.Add(newItem );\n                    }\n                    ContentViewModel = ToDoList;\n                });\n\n            ContentViewModel = addItemViewModel;\n        }\n    }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Take some time to examine the code that you just added. The main change is to the ",(0,o.jsx)(t.code,{children:"AddItem"})," method. This now sets up an observable that subscribes to the merged output of the two reactive commands (defined on the last page - in the add item view model)."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"Observable.Merge(\n                addItemViewModel.OkCommand,\n                addItemViewModel.CancelCommand.Select(_ => (ToDoItem?)null))\n"})}),"\n",(0,o.jsx)(t.p,{children:"This code takes advantage of the fact that a reactive command is itself an observable that has a value generated every time it is executed."}),"\n",(0,o.jsx)(t.p,{children:"The merge method combines the output from any number of observable streams, but they must have the same value type."}),"\n",(0,o.jsx)(t.p,{children:"You will remember that the two reactive command declarations were different. They were:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"public ReactiveCommand<Unit, ToDoItem> OkCommand { get; }\npublic ReactiveCommand<Unit, Unit> CancelCommand { get; }\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The OK command generates an object of class ",(0,o.jsx)(t.code,{children:"ToDoItem"})," whenever it executes, and the cancel command generates only a ",(0,o.jsx)(t.code,{children:"Unit"}),". The ",(0,o.jsx)(t.code,{children:"Unit"})," is the reactive version of ",(0,o.jsx)(t.code,{children:"void"})," - it means the command generates no value, but still notifies that it has happened!"]}),"\n",(0,o.jsxs)(t.p,{children:["So to combine the output from the different reactive command observable streams, the code converts the cancel command output into a stream of null ",(0,o.jsx)(t.code,{children:"ToDoItem"})," objects."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:".Take(1)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["You are only interested in the first click of either the OK or cancel buttons; once one of these buttons has been clicked other clicks can be ignored. So the ",(0,o.jsx)(t.a,{href:"https://reactivex.io/documentation/operators/take.html",children:(0,o.jsx)(t.code,{children:"Take(1)"})})," method means that only the first item in the observable sequence will be processed."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:".Subscribe(newItem =>\n{\n   if (newItem != null)\n   {\n      ToDoListViewModel.ListItems.Add(newItem);\n   }\n   ContentViewModel = ToDoList;\n});\n"})}),"\n",(0,o.jsx)(t.p,{children:"Lastly the code subscribes to the first item in the merged observable sequence. The subscribe pulls out the new to do item object, and examines it to see it it is null."}),"\n",(0,o.jsx)(t.p,{children:"A null value means that the cancel button was clicked - and no further action is required; except to restore the main window content to show the (unchanged) to do list."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"ContentViewModel = ToDoList;\n"})}),"\n",(0,o.jsxs)(t.p,{children:["If the value is not null, then it is because the OK button was clicked; and in this case the value should be a ",(0,o.jsx)(t.code,{children:"ToDoItem"})," containing the description that the user typed.  SO this can be added to the list."]}),"\n",(0,o.jsx)(t.p,{children:"You may notice one other important addition to the code here: The to do list view model has been declared as a public member of the main window view model. This will ensure the list is preserved during view changes; it acts as the application state for your app."}),"\n",(0,o.jsx)(t.p,{children:"Run the app to check it works as described!"}),"\n",(0,o.jsx)(t.p,{children:"On the next page you will learn why the app was implemented in the way that it has been, and recommended some further reading."})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(r,{...e})}):r(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>d,a:()=>a});var o=n(67294);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);