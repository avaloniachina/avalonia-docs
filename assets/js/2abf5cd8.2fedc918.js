"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[13053],{79304:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>t,metadata:()=>l,toc:()=>d});var s=n(85893),a=n(11151);const o=n.p+"assets/images/mvvm-f6b78a764c225a6a7555399580f78d6e.png",t={id:"mvvm",title:"MVVM Architecture"},r=void 0,l={id:"guides/basics/mvvm",title:"MVVM Architecture",description:"The Model-View-ViewModel pattern (MVVM) is a common way of structuring a UI application. It takes advantage of Avalonia's binding system to separate the logic of the application from the display of the application.",source:"@site/versioned_docs/version-0.10.x/guides/basics/mvvm.md",sourceDirName:"guides/basics",slug:"/guides/basics/mvvm",permalink:"/avalonia-docs/docs/0.10.x/guides/basics/mvvm",draft:!1,unlisted:!1,editUrl:"https://github.com/AvaloniaUI/avalonia-docs/tree/main/versioned_docs/version-0.10.x/guides/basics/mvvm.md",tags:[],version:"0.10.x",frontMatter:{id:"mvvm",title:"MVVM Architecture"},sidebar:"documentationSidebar",previous:{title:"Code Behind",permalink:"/avalonia-docs/docs/0.10.x/guides/basics/code-behind"},next:{title:"Accessing the UI thread",permalink:"/avalonia-docs/docs/0.10.x/guides/basics/accessing-the-ui-thread"}},c={},d=[{value:"When to use MVVM",id:"when-to-use-mvvm",level:2},{value:"Views and ViewModels",id:"views-and-viewmodels",level:2},{value:"Models",id:"models",level:2},{value:"Services",id:"services",level:2},{value:"Frameworks",id:"frameworks",level:2}];function h(e){const i={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(i.p,{children:["The Model-View-ViewModel pattern (MVVM) is a common way of structuring a UI application. It takes advantage of Avalonia's ",(0,s.jsx)(i.a,{href:"../../data-binding",children:"binding"})," system to separate the logic of the application from the display of the application."]}),"\n",(0,s.jsxs)(i.p,{children:["MVVM might be overkill for a simple application, but as applications grow over time, they usually reach a point where tracking logic in ",(0,s.jsx)(i.a,{href:"code-behind",children:"code-behind"})," becomes problematic for two main reasons:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"The interactions between UI components becomes overly complicated and error-prone"}),"\n",(0,s.jsx)(i.li,{children:"It's very difficult to unit test code in code-behind"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"MVVM solves this by abstracting the user interface into regular .NET classes that can be unit tested like any other classes."}),"\n",(0,s.jsx)(i.p,{children:"This is intended as a brief introduction to MVVM, there are many resources online that go into this subject in more depth."}),"\n",(0,s.jsx)(i.h2,{id:"when-to-use-mvvm",children:"When to use MVVM"}),"\n",(0,s.jsx)(i.p,{children:"First of all, MVVM has overhead in terms of complexity."}),"\n",(0,s.jsxs)(i.p,{children:["Because the advantages of using the MVVM pattern usually only become apparent when an application becomes more complex, it is often difficult to understand from simple examples ",(0,s.jsx)(i.em,{children:"why"})," MVVM should be used. Indeed if your application is going to remain small, using code-behind may well be easier to understand and maintain."]}),"\n",(0,s.jsx)(i.p,{children:"Many people prefer to start off their application using code-behind and once this starts proving problematic, refactor to use the MVVM pattern. This step usually happens while the application is relatively simple so generally doesn't take too much time."}),"\n",(0,s.jsx)(i.h2,{id:"views-and-viewmodels",children:"Views and ViewModels"}),"\n",(0,s.jsxs)(i.p,{children:["When we talk about the MVVM pattern, the most important parts are the ",(0,s.jsx)(i.strong,{children:"View"})," layer and the ",(0,s.jsx)(i.strong,{children:"ViewModel"})," layer. Views are usually implemented as ",(0,s.jsx)(i.a,{href:"../../controls/window",children:(0,s.jsx)(i.code,{children:"Window"})}),"s and ",(0,s.jsx)(i.a,{href:"../../controls/usercontrol",children:(0,s.jsx)(i.code,{children:"UserControl"})}),"s while ViewModels are .NET classes."]}),"\n",(0,s.jsx)(i.p,{children:"One way to imagine an MVVM application is to imagine these two layers as hovering over one another, connected by bindings:"}),"\n",(0,s.jsx)("img",{className:"center",src:o,alt:""}),"\n",(0,s.jsx)(i.p,{children:"The above example has, at the View layer:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["A ",(0,s.jsx)(i.code,{children:"MainWindow"})," which is an Avalonia ",(0,s.jsx)(i.code,{children:"Window"})," containing;"]}),"\n",(0,s.jsxs)(i.li,{children:["A ",(0,s.jsx)(i.code,{children:"Document"})," which is an Avalonia ",(0,s.jsx)(i.code,{children:"UserControl"})," containing;"]}),"\n",(0,s.jsxs)(i.li,{children:["Two ",(0,s.jsx)(i.code,{children:"TextBox"}),"es: ",(0,s.jsx)(i.code,{children:"Name"})," and ",(0,s.jsx)(i.code,{children:"Address"})]}),"\n",(0,s.jsxs)(i.li,{children:["Two ",(0,s.jsx)(i.code,{children:"Button"}),"s: ",(0,s.jsx)(i.code,{children:"OK"})," and ",(0,s.jsx)(i.code,{children:"Cancel"})]}),"\n",(0,s.jsx)(i.li,{children:"Various bindings, indicated by arrows"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"At the ViewModel layer there are .NET classes which mirror the view layer:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["A ",(0,s.jsx)(i.code,{children:"MainWindowViewModel"})," which has a property containing;"]}),"\n",(0,s.jsxs)(i.li,{children:["A ",(0,s.jsx)(i.code,{children:"DocumentViewModel"})," which has;"]}),"\n",(0,s.jsxs)(i.li,{children:["Two ",(0,s.jsx)(i.code,{children:"string"})," properties: ",(0,s.jsx)(i.code,{children:"Name"})," and ",(0,s.jsx)(i.code,{children:"Address"})]}),"\n",(0,s.jsxs)(i.li,{children:["Two methods: ",(0,s.jsx)(i.code,{children:"Ok"})," and ",(0,s.jsx)(i.code,{children:"Cancel"})]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["The ViewModel layer knows nothing of the view layer, so it is ",(0,s.jsx)(i.em,{children:"independent"})," of Avalonia. Each View usually has a corresponding ViewModel which contains all of the logic for the View. The View layer is connected to the ViewModel layer by bindings. Because the ViewModel layer is independent of Avalonia, it can be unit tested like any other code."]}),"\n",(0,s.jsx)(i.h2,{id:"models",children:"Models"}),"\n",(0,s.jsx)(i.p,{children:"The Model layer is the lowest layer in an MVVM application. Models usually represent data read from a database, or classes from a low-level library which implements the business logic of the application. The Model layer will be very specific to each application."}),"\n",(0,s.jsx)(i.p,{children:"An example of a model might be a table row read from a database using Entity Framework."}),"\n",(0,s.jsx)(i.h2,{id:"services",children:"Services"}),"\n",(0,s.jsxs)(i.p,{children:["In addition, most applications will add ",(0,s.jsx)(i.em,{children:"services"})," to this mix, which usually implement the reading and writing of models and other application-specific logic."]}),"\n",(0,s.jsx)(i.h2,{id:"frameworks",children:"Frameworks"}),"\n",(0,s.jsxs)(i.p,{children:["There are a number of frameworks designed to help write applications using the MVVM pattern. ",(0,s.jsx)(i.a,{href:"https://reactiveui.net",children:"ReactiveUI"})," is one of the most popular and has support for Avalonia which can be added via the ",(0,s.jsx)(i.a,{href:"https://www.nuget.org/packages/Avalonia.ReactiveUI/",children:"Avalonia.ReactiveUI NuGet package"}),"."]})]})}function p(e={}){const{wrapper:i}={...(0,a.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},11151:(e,i,n)=>{n.d(i,{Z:()=>r,a:()=>t});var s=n(67294);const a={},o=s.createContext(a);function t(e){const i=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),s.createElement(o.Provider,{value:i},e.children)}}}]);