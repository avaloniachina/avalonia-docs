"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[57345],{3543:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>r});var t=n(85893),s=n(11151);const a={id:"localizing",title:"Localizing using ResX"},o=void 0,l={id:"guides/implementation-guides/localizing",title:"Localizing using ResX",description:"Localization is a crucial step in delivering a great user experience for a global audience. In .NET, the ResXResourceReader and ResXResourceWriter classes are used to read and write resources in an XML-based format (.resx). This guide will walk you through the process of localizing an Avalonia application using ResX files.",source:"@site/docs/guides/implementation-guides/localizing.md",sourceDirName:"guides/implementation-guides",slug:"/guides/implementation-guides/localizing",permalink:"/avalonia-docs/docs/guides/implementation-guides/localizing",draft:!1,unlisted:!1,editUrl:"https://github.com/AvaloniaUI/avalonia-docs/tree/main/docs/guides/implementation-guides/localizing.md",tags:[],version:"current",frontMatter:{id:"localizing",title:"Localizing using ResX"},sidebar:"documentationSidebar",previous:{title:"How To Use Design-time Data",permalink:"/avalonia-docs/docs/guides/implementation-guides/how-to-use-design-time-data"},next:{title:"How to use INotifyPropertyChanged",permalink:"/avalonia-docs/docs/guides/data-binding/inotifypropertychanged"}},c={},r=[{value:"Add ResX Files to the Project",id:"add-resx-files-to-the-project",level:2},{value:"Set the Culture",id:"set-the-culture",level:2},{value:"Use Localized Text in the View",id:"use-localized-text-in-the-view",level:2}];function d(e){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["Localization is a crucial step in delivering a great user experience for a global audience. In .NET, the ",(0,t.jsx)(i.code,{children:"ResXResourceReader"})," and ",(0,t.jsx)(i.code,{children:"ResXResourceWriter"})," classes are used to read and write resources in an XML-based format (.resx). This guide will walk you through the process of localizing an Avalonia application using ResX files."]}),"\n",(0,t.jsx)(i.admonition,{type:"info",children:(0,t.jsxs)(i.p,{children:["For a complete, runnable example of these concepts in action, check out the ",(0,t.jsx)(i.a,{href:"https://github.com/AvaloniaUI/AvaloniaUI.QuickGuides/tree/main/Localization/",children:"sample application"}),"."]})}),"\n",(0,t.jsx)(i.h2,{id:"add-resx-files-to-the-project",children:"Add ResX Files to the Project"}),"\n",(0,t.jsx)(i.p,{children:"Before localizing, you need to include ResX files for each language you want to support. For this guide, we'll consider three ResX files, one for each of the following cultures:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"Resources.fil-PH.resx"})," (Filipino)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"Resources.ja-JP.resx"})," (Japanese)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"Resources.resx"})," (Default language, usually English)"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Each ResX file will contain translated text that corresponds to the keys used in the application."}),"\n",(0,t.jsxs)(i.p,{children:["In this example, we added new files to the ",(0,t.jsx)(i.code,{children:"Assets"})," folder. Since .NET generator creates namespaces depending on folder structure, it might be different for you."]}),"\n",(0,t.jsx)(i.h2,{id:"set-the-culture",children:"Set the Culture"}),"\n",(0,t.jsxs)(i.p,{children:["To use a specific language in the application, you need to set the current culture. This can be done in the ",(0,t.jsx)(i.code,{children:"App.axaml.cs"})," file. The following example sets the culture to Filipino (",(0,t.jsx)(i.code,{children:"fil-PH"}),"):"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-cs",metastring:'title="App.xaml.cs"',children:'public partial class App : Application\n{\n    public override void Initialize()\n    {\n        AvaloniaXamlLoader.Load(this);\n    }\n\n    public override void OnFrameworkInitializationCompleted()\n    {\n        // highlight-start\n        Assets.Resources.Culture = new CultureInfo("fil-PH");\n        // highlight-end\n        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)\n        {\n            desktop.MainWindow = new MainWindow\n            {\n                DataContext = new MainWindowViewModel(),\n            };\n        }\n\n        base.OnFrameworkInitializationCompleted();\n    }\n}\n'})}),"\n",(0,t.jsx)(i.p,{children:'Replace "fil-PH" with the appropriate culture code as required.'}),"\n",(0,t.jsx)(i.h2,{id:"use-localized-text-in-the-view",children:"Use Localized Text in the View"}),"\n",(0,t.jsx)(i.p,{children:"To use the localized text in a view, you can refer to the resources statically in XAML:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-xml",children:'<TextBlock Text="{x:Static assets:Resources.GreetingText}"/>\n'})}),"\n",(0,t.jsxs)(i.p,{children:["In the above example, ",(0,t.jsx)(i.code,{children:"GreetingText"})," is the key that corresponds to a string in the ResX file. The ",(0,t.jsx)(i.code,{children:"{x:Static}"})," markup extension is used to reference a static property that's been defined in a .NET class, which, in this case, is the resources file (",(0,t.jsx)(i.code,{children:"assets:Resources.GreetingText"}),")."]}),"\n",(0,t.jsx)(i.p,{children:"That's it! You've now successfully localized your Avalonia application using ResX. By setting the culture to a different locale, you can display the user interface in the selected language, thereby creating an application that supports multiple languages and caters to a global audience."})]})}function u(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},11151:(e,i,n)=>{n.d(i,{Z:()=>l,a:()=>o});var t=n(67294);const s={},a=t.createContext(s);function o(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);