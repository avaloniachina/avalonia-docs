"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[57156],{23514:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=t(85893),n=t(11151);const s={id:"architecture",title:"Architecture"},r=void 0,o={id:"guides/building-cross-platform-applications/architecture",title:"Architecture",description:"A crucial aspect of building cross-platform applications with Avalonia is creating an architecture that enables maximum code sharing across different platforms. By adhering to the fundamental principles of Object-Oriented Programming, you can establish a well-structured application:",source:"@site/docs/guides/building-cross-platform-applications/architecture.md",sourceDirName:"guides/building-cross-platform-applications",slug:"/guides/building-cross-platform-applications/architecture",permalink:"/avalonia-docs/docs/guides/building-cross-platform-applications/architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/AvaloniaUI/avalonia-docs/tree/main/docs/guides/building-cross-platform-applications/architecture.md",tags:[],version:"current",frontMatter:{id:"architecture",title:"Architecture"},sidebar:"documentationSidebar",previous:{title:"Building Cross-Platform Applications",permalink:"/avalonia-docs/docs/guides/building-cross-platform-applications/"},next:{title:"Setting Up A Cross Platform Solution",permalink:"/avalonia-docs/docs/guides/building-cross-platform-applications/solution-setup"}},l={},c=[{value:"Typical Application Layers",id:"typical-application-layers",level:2},{value:"Common Architectual Patterns",id:"common-architectual-patterns",level:2},{value:"Model, View, ViewModel (MVVM)",id:"model-view-viewmodel-mvvm",level:3},{value:"Business Fa\xe7ade",id:"business-fa\xe7ade",level:3},{value:"Singleton",id:"singleton",level:3},{value:"Provider",id:"provider",level:3},{value:"Async",id:"async",level:3}];function d(e){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.p,{children:"A crucial aspect of building cross-platform applications with Avalonia is creating an architecture that enables maximum code sharing across different platforms. By adhering to the fundamental principles of Object-Oriented Programming, you can establish a well-structured application:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Encapsulation"})," \u2013 This involves ensuring that classes and architectural layers only expose a minimal API that performs their necessary functions while concealing the internal implementation details. In practical terms, this means that objects operate as 'black boxes', and the code utilizing them doesn't need to comprehend their internal workings. Architecturally, it implies implementing patterns like the Fa\xe7ade that promote a simplified API orchestrating more complex interactions on behalf of the code in higher abstract layers. Hence, the UI code should focus solely on displaying screens and accepting user input, never directly interacting with databases or other lower-level operations."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Separation of Responsibilities"})," \u2013 Every component, whether at the architectural or class level, should have a clear and defined purpose. Each component should perform its specified tasks and expose that functionality via an API accessible to other classes needing to use it."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Polymorphism"})," \u2013 Programming to an interface (or an abstract class) supporting multiple implementations allows core code to be written and shared across platforms while still interacting with platform-specific features offered by Avalonia."]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"The result of these principles is an application modelled after real-world or abstract entities with distinct logical layers."}),"\n",(0,a.jsx)(i.p,{children:"Separating code into layers makes the application easier to understand, test, and maintain. It's advisable to keep the code in each layer physically separate (either in different directories or even separate projects for larger applications) as well as logically separate (using namespaces). With Avalonia, you can share not just the business logic, but the UI code too across platforms, reducing the need for multiple UI projects and further enhancing code reuse."}),"\n",(0,a.jsx)(i.h2,{id:"typical-application-layers",children:"Typical Application Layers"}),"\n",(0,a.jsx)(i.p,{children:"In this document and the relevant case studies, we reference the following five application layers:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Data Layer"})," \u2013 This is where non-volatile data persistence occurs, likely through a database like SQLite or LiteDB, but could be implemented with XML files or other suitable mechanisms."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Data Access Layer"})," \u2013 This layer is a wrapper around the Data Layer providing Create, Read, Update, Delete (CRUD) operations on the data without revealing implementation details to the caller. For instance, the DAL might contain SQL queries to interact with the data, but the code referencing it doesn't need to be aware of this."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Business Layer"})," \u2013 Sometimes referred to as the Business Logic Layer or BLL, this layer houses business entity definitions (the Model) and business logic. It is a prime candidate for the Business Facade pattern."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Service Access Layer"})," \u2013 This layer is used to access services in the cloud, ranging from complex web services (REST, JSON) to simple retrieval of data and images from remote servers. It encapsulates networking behaviour and provides a streamlined API for consumption by the Application and UI layers."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Application Layer"})," \u2013 This layer contains code that is generally platform-specific or code that is specific to the application (not typically reusable). In the Avalonia framework, this layer is where you decide which platform-specific features to leverage if any. The distinction between this layer and the UI layer becomes clearer with Avalonia since the UI code can be shared across platforms."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"User Interface (UI) Layer"})," \u2013 This user-facing layer contains views and the view-models that manage them. Avalonia makes it possible for this layer shared across every supported platform, unlike traditional architectures where the UI layer would be platform-specific."]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"An application might not contain all layers \u2013 for instance, the Service Access Layer would not be present in an application that doesn't access network resources. A simpler application might merge the Data Layer and Data Access Layer because the operations are extremely basic. With Avalonia, you have the flexibility to shape your application architecture to suit your specific needs, enjoying a high degree of code reusability across platforms."}),"\n",(0,a.jsx)(i.h2,{id:"common-architectual-patterns",children:"Common Architectual Patterns"}),"\n",(0,a.jsx)(i.p,{children:"Patterns are a well-established approach to capture recurring solutions to common problems. There are several key patterns that are valuable to comprehend when building maintainable and understandable applications with Avalonia."}),"\n",(0,a.jsx)(i.h3,{id:"model-view-viewmodel-mvvm",children:"Model, View, ViewModel (MVVM)"}),"\n",(0,a.jsx)(i.p,{children:"A popular and often misunderstood pattern, MVVM is primarily employed when constructing User Interfaces and promotes a separation between the actual definition of a UI Screen (View), the logic behind it (ViewModel), and the data that populates it (Model). The ViewModel acts as an intermediary between the View and the Model. The Model, although crucial, is a distinct and optional piece, and thus, the essence of understanding this pattern resides in the relationship between the View and ViewModel."}),"\n",(0,a.jsx)(i.admonition,{type:"info",children:(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.a,{href:"../../concepts/the-mvvm-pattern/",children:"Learn more about MVVM"}),"."]})}),"\n",(0,a.jsx)(i.h3,{id:"business-fa\xe7ade",children:"Business Fa\xe7ade"}),"\n",(0,a.jsx)(i.p,{children:"Also known as the Manager Pattern, this provides a simplified point of entry for intricate operations. For instance, in a Task Tracking application, you might have a TaskManager class with methods such as GetAllTasks(), GetTask(taskID), SaveTask (task), etc. The TaskManager class provides a Fa\xe7ade to the inner mechanisms of saving/retrieving tasks objects."}),"\n",(0,a.jsx)(i.h3,{id:"singleton",children:"Singleton"}),"\n",(0,a.jsx)(i.p,{children:"The Singleton pattern ensures that only a single instance of a particular object can ever exist. For example, when using SQLite in applications, you typically want only one instance of the database. The Singleton pattern is an efficient method to enforce this."}),"\n",(0,a.jsx)(i.h3,{id:"provider",children:"Provider"}),"\n",(0,a.jsx)(i.p,{children:"A pattern originally coined by Microsoft to promote code re-use across Silverlight, WPF and WinForms applications. Shared code can be written against an interface or abstract class, and platform-specific concrete implementations are written and passed in when the code is utilised. In Avalonia, since we can share both UI and application logic, this pattern can help handle platform-specific exceptions or leverage platform-specific features."}),"\n",(0,a.jsx)(i.h3,{id:"async",children:"Async"}),"\n",(0,a.jsxs)(i.p,{children:["Not to be confused with the ",(0,a.jsx)(i.code,{children:"Async"})," keyword, the Async pattern is used when long-running tasks need to be executed without holding up the UI or current processing. In its simplest form, the Async pattern describes that long-running tasks should be kicked off in another thread (or a similar thread abstraction such as a Task) while the current thread continues to process and listens for a response from the background process, updating the UI when data and/or state is returned. This is essential in maintaining a responsive UI in Avalonia applications."]}),"\n",(0,a.jsx)(i.hr,{}),"\n",(0,a.jsxs)(i.p,{children:["Each of the aforementioned patterns will be explored in-depth as their practical application is demonstrated in our case studies. For a more comprehensive understanding of the ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Facade_pattern",children:"Facade"}),", ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Singleton_pattern",children:"Singleton"}),", and ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Provider_model",children:"Provider"})," patterns, as well as ",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Design_Patterns",children:"Design Patterns"})," in general, you may want to delve into resources available on platforms like Wikipedia."]})]})}function h(e={}){const{wrapper:i}={...(0,n.a)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,i,t)=>{t.d(i,{Z:()=>o,a:()=>r});var a=t(67294);const n={},s=a.createContext(n);function r(e){const i=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(s.Provider,{value:i},e.children)}}}]);