"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[72283],{95141:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var i=t(85893),o=t(11151);const r={description:"CONCEPTS - ReactiveUI"},c="Binding to Sorted/Filtered Data",a={id:"concepts/reactiveui/binding-to-sorted-filtered-list",title:"Binding to Sorted/Filtered Data",description:"CONCEPTS - ReactiveUI",source:"@site/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reactiveui/binding-to-sorted-filtered-list.md",sourceDirName:"concepts/reactiveui",slug:"/concepts/reactiveui/binding-to-sorted-filtered-list",permalink:"/avalonia-docs/ru/docs/concepts/reactiveui/binding-to-sorted-filtered-list",draft:!1,unlisted:!1,editUrl:"https://github.com/AvaloniaUI/avalonia-docs/tree/main/i18n/ru/docusaurus-plugin-content-docs/current/concepts/reactiveui/binding-to-sorted-filtered-list.md",tags:[],version:"current",frontMatter:{description:"CONCEPTS - ReactiveUI"},sidebar:"documentationSidebar",previous:{title:"Data Persistence",permalink:"/avalonia-docs/ru/docs/concepts/reactiveui/data-persistence"},next:{title:"Pseudo Classes",permalink:"/avalonia-docs/ru/docs/concepts/pseudo-classes"}},s={},d=[{value:"Creating a Source Cache",id:"creating-a-source-cache",level:2},{value:"Creating Sorted Or Filtered Views",id:"creating-sorted-or-filtered-views",level:2},{value:"Binding",id:"binding",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"binding-to-sortedfiltered-data",children:"Binding to Sorted/Filtered Data"}),"\n",(0,i.jsxs)(n.p,{children:["A common UI task that applications need to do is display sorted and/or filtered 'views' of data. In Avalonia this can be accomplished by connecting a ",(0,i.jsx)(n.code,{children:"SourceCache<TObject, TKey>"})," or a ",(0,i.jsx)(n.code,{children:"SourceList<T>"})," to a ",(0,i.jsx)(n.code,{children:"ReadOnlyObservableCollection<T>"})," and binding to that collection"]}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-source-cache",children:"Creating a Source Cache"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"SourceCache<TObject, TKey>"})," or ",(0,i.jsx)(n.code,{children:"SourceList<T>"})," come from ",(0,i.jsx)(n.a,{href:"https://www.reactiveui.net/docs/handbook/collections/",children:"Dynamic Data in ReactiveUI"})," Example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// (x => x.Id) property that serves as the unique key for the cache\nprivate SourceCache<TestViewModel, Guid> _sourceCache = new (x => x.Id);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Then the ",(0,i.jsx)(n.code,{children:"_sourceCache"})," can be populated through the ",(0,i.jsx)(n.code,{children:"AddOrUpdate"})," method"]}),"\n",(0,i.jsx)(n.h2,{id:"creating-sorted-or-filtered-views",children:"Creating Sorted Or Filtered Views"}),"\n",(0,i.jsxs)(n.p,{children:["Next the ",(0,i.jsx)(n.code,{children:"ReadOnlyObservableCollection<T>"})," can be bound to the filtered or sorted ",(0,i.jsx)(n.code,{children:"_sourceCache"}),". The sorting/filtering is done similarly to linq."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"private readonly ReadOnlyObservableCollection<TestViewModel> _testViewModels;\npublic ReadOnlyObservableCollection<TestViewModel> TestViewModels => _testViewModels;\n...\npublic MainWindowViewModel(){\n    // Populate the source cache via _sourceCache.AddOrUpdate\n    ...\n    _sourceCache.Connect()\n        // Sort Ascending on the OrderIndex property\n        .Sort(SortExpressionComparer<TestViewModel>.Ascending(t => t.OrderIndex))\n        .Filter(x => x.Id.ToString().EndsWith('1'))\n        // Bind to our ReadOnlyObservableCollection<T>\n        .Bind(out _testViewModels)\n        // Subscribe for changes\n        .Subscribe();\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"binding",children:"Binding"}),"\n",(0,i.jsxs)(n.p,{children:["Now that the ",(0,i.jsx)(n.code,{children:"_sourceCache"})," is created and populated and the ",(0,i.jsx)(n.code,{children:"ReadOnlyObservableCollection<T>"})," is created and bound we can go into our view and bind exactly the way we normally would with an ",(0,i.jsx)(n.code,{children:"ObservableCollection<T>"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-markup",children:'    <Design.DataContext>\n        <vm:MainWindowViewModel/>\n    </Design.DataContext>\n\n    <TreeView ItemsSource="{Binding TestViewModels}">\n        <TreeView.DataTemplates>\n            !-- DataTemplate Definitions --\x3e\n        </TreeView.DataTemplates> \n    </TreeView>\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>c});var i=t(67294);const o={},r=i.createContext(o);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);